{"remainingRequest":"C:\\Maike\\gluecksrad-adjektive\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Maike\\gluecksrad-adjektive\\src\\components\\Wheel.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"C:\\Maike\\gluecksrad-adjektive\\src\\components\\Wheel.vue","mtime":1612008972084},{"path":"C:\\Maike\\gluecksrad-adjektive\\node_modules\\css-loader\\dist\\cjs.js","mtime":1612009265912},{"path":"C:\\Maike\\gluecksrad-adjektive\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":1612009266838},{"path":"C:\\Maike\\gluecksrad-adjektive\\node_modules\\postcss-loader\\src\\index.js","mtime":1612009266733},{"path":"C:\\Maike\\gluecksrad-adjektive\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1612009238007},{"path":"C:\\Maike\\gluecksrad-adjektive\\node_modules\\vue-loader\\lib\\index.js","mtime":1612009266838}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoNCi53aGVlbHMtY29udGFpbmVyIHsNCiAgcG9zaXRpb246IHJlbGF0aXZlOw0KICBmbGV4OiAxIDEgYXV0bzsNCiAgaGVpZ2h0OiAxMDAlOw0KICBtYXgtaGVpZ2h0OiAxMDAlOw0KICBtYXgtd2lkdGg6IDEwMCU7DQogIG92ZXJmbG93OiBoaWRkZW47DQp9DQoud2hlZWxzIHsNCiAgbWFyZ2luOiAwOw0KICBwYWRkaW5nOiAwOw0KICBoZWlnaHQ6IDEwMCU7DQogIHdpZHRoOiAxMDAlOw0KICBtYXgtaGVpZ2h0OiAxMDAlOw0KICBtYXgtd2lkdGg6IDEwMCU7DQogIG92ZXJmbG93OiBoaWRkZW47DQp9DQoud2hlZWwtY29udGFpbmVyIHsNCiAgcG9zaXRpb246IGFic29sdXRlOw0KICBsZWZ0OiAwOw0KICByaWdodDogMDsNCiAgdG9wOiAwOw0KICBib3R0b206IDA7DQp9DQoud2hlZWwtbWFpbiwNCi53aGVlbC1zdWIgew0KICBtYXJnaW46IDA7DQogIHBhZGRpbmc6IDA7DQogIGhlaWdodDogMTAwJTsNCiAgd2lkdGg6IDEwMCU7DQogIG1heC1oZWlnaHQ6IDEwMCU7DQogIG1heC13aWR0aDogMTAwJTsNCiAgb3ZlcmZsb3c6IGhpZGRlbjsNCn0NCi53aGVlbC1zdWIgew0KICB6LWluZGV4OiAyOw0KfQ0K"},{"version":3,"sources":["Wheel.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Wheel.vue","sourceRoot":"src/components","sourcesContent":["<template>\r\n  <div class=\"wheels-container\">\r\n    <div class=\"wheels\">\r\n      <div class=\"wheel-container\">\r\n        <canvas class=\"wheel-main\" ref=\"mainCanvas\" />\r\n      </div>\r\n      <div class=\"wheel-container\">\r\n        <canvas class=\"wheel-sub\" ref=\"subCanvas\" />\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { DEFAULT_FREQUENCY, DEFAULT_TEXT_COLOR, getDefaultBgColor, getTotalFrequency } from '../data';\r\nimport { getRandomInt } from '../util';\r\n\r\n// Calculate the resulting prize index given the final angle and list of prizes.\r\nfunction calculateResult(angle, prizes) {\r\n  const totalFreqs = getTotalFrequency(prizes);\r\n  let cumulative = 0;\r\n  let winner = -1;\r\n\r\n  for (let i = 0; i < prizes.length; ++i) {\r\n    const freq = prizes[i].freq || DEFAULT_FREQUENCY;\r\n    cumulative += freq;\r\n\r\n    const arcAngle1 = angle + (2 * Math.PI * (cumulative - freq)) / totalFreqs;\r\n    const arcAngle2 = angle + (2 * Math.PI * cumulative) / totalFreqs;\r\n    if (isAngleBetween((3 / 2) * Math.PI, arcAngle1, arcAngle2)) {\r\n      winner = i;\r\n    }\r\n  }\r\n\r\n  return winner;\r\n}\r\n\r\n// Returns true if the given angle is between the specified bounds.\r\nfunction isAngleBetween(angle, lower, upper) {\r\n  lower %= 2 * Math.PI;\r\n  upper %= 2 * Math.PI;\r\n  if (lower <= upper) {\r\n    return lower < angle && upper >= angle;\r\n  } else {\r\n    return lower < angle || upper >= angle;\r\n  }\r\n}\r\n\r\n// Redraw the wheel onto the given canvas, with the given offset angle and list of prizes.\r\nfunction redrawWheel(canvas, angle, prizes) {\r\n  const r = Math.min(canvas.width, canvas.height) / 2.05;\r\n  const cx = canvas.width / 2;\r\n  const cy = canvas.height / 2;\r\n  const ctx = canvas.getContext('2d');\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n  let g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);\r\n  g.addColorStop(0, 'rgba(0,0,0,0)');\r\n  g.addColorStop(1, 'rgba(0,0,0,0.1)');\r\n\r\n  const totalFreqs = getTotalFrequency(prizes);\r\n  let cumulative = 0;\r\n  for (let i = 0; i < prizes.length; ++i) {\r\n    const prize = prizes[i];\r\n    const freq = prize.freq || DEFAULT_FREQUENCY;\r\n    cumulative += freq;\r\n\r\n    // calculate arc and text angles\r\n    const arcAngle1 = angle + (2 * Math.PI * (cumulative - freq)) / totalFreqs;\r\n    const arcAngle2 = angle + (2 * Math.PI * cumulative) / totalFreqs;\r\n    const textAngle = angle + (2 * Math.PI * (cumulative - freq / 2)) / totalFreqs;\r\n    const highlight = isAngleBetween((3 / 2) * Math.PI, arcAngle1, arcAngle2);\r\n\r\n    // draw arc\r\n    ctx.beginPath();\r\n    ctx.moveTo(cx, cy);\r\n    ctx.arc(cx, cy, r, arcAngle1, arcAngle2, false);\r\n    ctx.fillStyle = prize.bg || getDefaultBgColor(i);\r\n    ctx.fill();\r\n    ctx.fillStyle = g;\r\n    ctx.fill();\r\n    ctx.save();\r\n\r\n    // calculate font size\r\n    const angleMod = Math.min(arcAngle2 - arcAngle1, 0.25);\r\n    const lengthMod = 1 - Math.round(prize.name.length / 3) * 0.07;\r\n    const fontMod = prize.fontMod || 1;\r\n    const fontSize = Math.max(10, 0.4 * r * angleMod * lengthMod * fontMod);\r\n\r\n    // draw text\r\n    ctx.fillStyle = prize.text || DEFAULT_TEXT_COLOR;\r\n    if (highlight) {\r\n      ctx.shadowColor = prize.text || DEFAULT_TEXT_COLOR;\r\n      ctx.shadowBlur = r / 15;\r\n    }\r\n    ctx.font = fontSize + \"px 'Muli', sans-serif\";\r\n    ctx.textAlign = 'right';\r\n    ctx.textBaseline = 'middle';\r\n    ctx.translate(cx, cy);\r\n    ctx.rotate(textAngle);\r\n    ctx.fillText(prize.name, r * 0.91, 0);\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\n// Redraw the wheel frame onto the given canvas.\r\nfunction redrawFrame(canvas) {\r\n  const r = Math.min(canvas.width, canvas.height) / 2.05;\r\n  const cx = canvas.width / 2;\r\n  const cy = canvas.height / 2;\r\n  const ctx = canvas.getContext('2d');\r\n\r\n  // outer ring\r\n  ctx.save();\r\n  ctx.shadowOffsetX = r / 100;\r\n  ctx.shadowOffsetY = r / 100;\r\n  ctx.shadowBlur = r / 40;\r\n  ctx.shadowColor = 'rgba(0,0,0,0.2)';\r\n  ctx.beginPath();\r\n  ctx.arc(cx, cy, r * 1.005, 0, 2 * Math.PI, true);\r\n  ctx.arc(cx, cy, r * 0.985, 0, 2 * Math.PI, false);\r\n  ctx.fillStyle = '#424242';\r\n  ctx.fill();\r\n\r\n  // center ring\r\n  ctx.shadowOffsetX = r / 100;\r\n  ctx.shadowOffsetY = r / 100;\r\n  ctx.fillStyle = '#424242';\r\n  ctx.beginPath();\r\n  ctx.arc(cx, cy, r / 30, 0, 2 * Math.PI, false);\r\n  ctx.fill();\r\n\r\n  // prize pointer\r\n  ctx.translate(cx, cy);\r\n  ctx.rotate(Math.PI / 2);\r\n  ctx.beginPath();\r\n  ctx.moveTo(-r * 1.01, -r * 0.05);\r\n  ctx.lineTo(-r * 0.935, 0);\r\n  ctx.lineTo(-r * 1.01, r * 0.05);\r\n  ctx.fillStyle = '#f44336';\r\n  ctx.fill();\r\n  ctx.restore();\r\n}\r\n\r\nexport default {\r\n  name: 'Wheel',\r\n  data() {\r\n    return {\r\n      angle: 0,\r\n      resizeIntervalId: null\r\n    };\r\n  },\r\n  computed: {\r\n    prizes() {\r\n      return this.$store.state.available;\r\n    },\r\n    removeWinning() {\r\n      return this.$store.state.data.removeWinning || false;\r\n    }\r\n  },\r\n  methods: {\r\n    // Resize and repaint the wheel if the size of the canvas changes.\r\n    resize() {\r\n      const mainCanvas = this.$refs.mainCanvas;\r\n      const subCanvas = this.$refs.subCanvas;\r\n      const pixelRatio = window.devicePixelRatio || 1;\r\n      const desiredWidth = mainCanvas.offsetWidth * pixelRatio;\r\n      const desiredHeight = mainCanvas.offsetHeight * pixelRatio;\r\n      if (mainCanvas.width !== desiredWidth || mainCanvas.height !== desiredHeight) {\r\n        mainCanvas.width = desiredWidth;\r\n        mainCanvas.height = desiredHeight;\r\n        subCanvas.width = desiredWidth;\r\n        subCanvas.height = desiredHeight;\r\n        this.$store.commit('updateWheelSize', Math.min(mainCanvas.width, mainCanvas.height));\r\n        window.requestAnimationFrame(() => {\r\n          redrawWheel(mainCanvas, this.angle, this.prizes);\r\n          redrawFrame(subCanvas);\r\n        });\r\n      }\r\n    },\r\n\r\n    // Determine the winner and notify parent.\r\n    spinCompleted() {\r\n      const winner = calculateResult(this.angle, this.prizes);\r\n      this.$store.commit('addSpinResult', winner);\r\n      this.$emit('result', winner);\r\n    },\r\n\r\n    // Start spinning. Called by parent (WheelPanel).\r\n    startSpin() {\r\n      const mainCanvas = this.$refs.mainCanvas;\r\n      const prizes = this.prizes;\r\n      const self = this;\r\n\r\n      const totalTicks = getRandomInt(450, 530);\r\n      const speed = 0.12 + getRandomInt(0, 80) * 0.001;\r\n      let ticks = 0;\r\n      const start = +new Date();\r\n\r\n      function mainLoop() {\r\n        const now = +new Date();\r\n        const targetTicks = Math.min(totalTicks, (now - start) / 10);\r\n        for (; ticks <= targetTicks; ++ticks) {\r\n          self.angle += (speed * (totalTicks - ticks)) / totalTicks;\r\n        }\r\n\r\n        redrawWheel(mainCanvas, self.angle, prizes);\r\n\r\n        if (ticks < totalTicks) {\r\n          window.requestAnimationFrame(mainLoop);\r\n        } else {\r\n          self.spinCompleted();\r\n        }\r\n      }\r\n\r\n      window.requestAnimationFrame(mainLoop);\r\n    }\r\n  },\r\n  mounted() {\r\n    this.resizeIntervalId = setInterval(this.resize, 10);\r\n  },\r\n  beforeDestroy() {\r\n    clearInterval(this.resizeIntervalId);\r\n  }\r\n};\r\n</script>\r\n\r\n<style>\r\n.wheels-container {\r\n  position: relative;\r\n  flex: 1 1 auto;\r\n  height: 100%;\r\n  max-height: 100%;\r\n  max-width: 100%;\r\n  overflow: hidden;\r\n}\r\n.wheels {\r\n  margin: 0;\r\n  padding: 0;\r\n  height: 100%;\r\n  width: 100%;\r\n  max-height: 100%;\r\n  max-width: 100%;\r\n  overflow: hidden;\r\n}\r\n.wheel-container {\r\n  position: absolute;\r\n  left: 0;\r\n  right: 0;\r\n  top: 0;\r\n  bottom: 0;\r\n}\r\n.wheel-main,\r\n.wheel-sub {\r\n  margin: 0;\r\n  padding: 0;\r\n  height: 100%;\r\n  width: 100%;\r\n  max-height: 100%;\r\n  max-width: 100%;\r\n  overflow: hidden;\r\n}\r\n.wheel-sub {\r\n  z-index: 2;\r\n}\r\n</style>\r\n"]}]}